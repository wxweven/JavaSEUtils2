package com.wxweven.disruptors;import com.lmax.disruptor.RingBuffer;import com.lmax.disruptor.YieldingWaitStrategy;import com.lmax.disruptor.dsl.Disruptor;import com.lmax.disruptor.dsl.ProducerType;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/** * Created with IntelliJ IDEA. * Project: test-jar * Author: Kevin * Date: 16/5/23 * Time: 下午4:23 */public class SimpleDemo {    private static final int BUFFER_SIZE = 1024;    public static void main(String[] args) {        ExecutorService executors = Executors.newCachedThreadPool();        Disruptor<TestObject> disruptor = new Disruptor<>(                new TestObjectFactory(),                BUFFER_SIZE,                executors,                ProducerType.SINGLE,                new YieldingWaitStrategy()        );        disruptor.handleEventsWith(new TestObjectAnalysisHandler());        RingBuffer<TestObject> ringBuffer = disruptor.start();        for (long i = 0; i < 1000; i++) {            long seq = ringBuffer.next();            try {                TestObject valueEvent = ringBuffer.get(seq);                valueEvent.setValue(i);            } finally {                //发布通知，并且这一步一定要放在finally中，因为调用了ringBuffer.next(),就一定要发布，否则会导致错乱                ringBuffer.publish(seq);            }        }        disruptor.shutdown();        executors.shutdown();    }}