package com.wxweven.disruptors;import com.lmax.disruptor.BlockingWaitStrategy;import com.lmax.disruptor.RingBuffer;import com.lmax.disruptor.SequenceBarrier;import com.lmax.disruptor.Sequencer;import java.util.concurrent.LinkedBlockingQueue;/** * Created with IntelliJ IDEA. * Project: test-jar * Author: Kevin Date: * 16/5/24 Time: 下午12:04 */public class CompareDemo {    final long objSize = 1 << 20;    public void testLinkedBlockQueue() throws Exception {        final LinkedBlockingQueue<TestObject> queue = new LinkedBlockingQueue<>();        Thread producer = new Thread(() -> {            try {                for (long i = 1; i <= objSize; i++) {                    queue.add(new TestObject(i));                }            } catch (Exception e) {                e.printStackTrace();            }        });        Thread consumer = new Thread(() -> {            try {                TestObject readObj;                for (long i = 1; i <= objSize; i++) {                    // do something                    readObj = queue.remove();                    System.out.println(readObj);                }            } catch (Exception e) {                e.printStackTrace();            }        });        long timeStart = System.currentTimeMillis();        producer.start();        consumer.start();        consumer.join();        producer.join();        System.out.println("linkedQueue用时：" + (System.currentTimeMillis() - timeStart));    }    public void testRingBuffer() throws Exception {        // 创建一个单生产者的RingBuffer，EventFactory是填充缓冲区的对象工厂        final RingBuffer<TestObject> ringBuffer = RingBuffer.createSingleProducer(                () -> new TestObject(0),                (int) objSize,                new BlockingWaitStrategy());        // 创建消费者指针        final SequenceBarrier barrier = ringBuffer.newBarrier();        Thread producer = new Thread(() -> {// 生产者            for (long i = 1; i <= objSize; i++) {                long index;// 申请下一个缓冲区Slot                index = ringBuffer.next();                try {                    ringBuffer.get(index).setValue(i);// 对申请到的Slot赋值                } finally {                    ringBuffer.publish(index);// 发布，然后消费者可以读到                }            }        });        Thread consumer = new Thread(() -> {// 消费者            TestObject readObj = null;            int readCount = 0;            long readIndex = Sequencer.INITIAL_CURSOR_VALUE;            while (readCount < objSize)// 读取objCount个元素后结束            {                try {                    long nextIndex = readIndex + 1;// 消费者下一个可以消费的地址                    long availableIndex = barrier                            .waitFor(nextIndex);// 等待直到上面的位置可读取                    while (nextIndex <= availableIndex) {                        readObj = ringBuffer.get(nextIndex);// 获得Buffer中的对象                        // DoSomethingAbout(readObj);                        readCount++;                        nextIndex++;                    }                    readIndex = availableIndex;// 刷新当前读取到的位置                } catch (Exception ex) {                    ex.printStackTrace();                }            }        });        long timeStart = System.currentTimeMillis();        producer.start();        consumer.start();        consumer.join();        producer.join();        System.out.println("Disruptor用时：" + (System.currentTimeMillis() - timeStart));    }    public static void main(String[] args) throws Exception {        CompareDemo compareDemo = new CompareDemo();        compareDemo.testLinkedBlockQueue();        compareDemo.testRingBuffer();    }}